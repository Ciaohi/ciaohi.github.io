---
title: 美团面试Q&A
date: 2019-10-19 11:23:25
tags: [数据结构,map]
---

## 面试现场

Q1:你了解HashMap和TreeMap的区别吗?

A1:HashMap是一个常用的**数据结构**，它主要用于我们有固定值(key)获取内容的场景，时间复杂度可以最快优化到O(1),效果不好的时候时间复杂度是O(logN)或者O(N)。虽然固定值查找提高了速度,但是HashMap不能保证固定值,也就是key的顺序,所以这个时候**TreeMap**为了解决这个问题就出现了,虽然它的查找、删除、更新的时间复杂度都是O(logN),但是他可以保证key的有序性.

----------------

Q2:那你和我说说HashMap和TreeMap的底层实现有什么不同,才导致的他们有这么大的差异呢?

A2:HashMap使用的是数组(桶)和哈希的方式实现，巧妙通过key的哈希路由到每一个数组用于存放内容，这时候通过key获取value的时间复杂度就是O(1),当然因为key的哈希可能碰撞,所以就需要针对碰撞的时候做处理,HashMap里面每一个数组(桶)里面存的其实是一个**链表**，key的**哈希冲突**以后会追加到链表上面,这时候再通过Key获取value的时候时间复杂度就变成了O(n),那么数据碰撞越来越多的时候岂不是导致查询很慢?为了优化这个时间复杂度,HashMap当一个key碰撞次数超过*TREEIFY THRESHOLD*的时候就会把链表转换成**红黑树**，这样虽然插入的时候也增加了时间复杂度，但是对于频繁哈希碰撞的问题的查询效率有很大的提高，使得查询的时间复杂度变成了O(logN)。说到红黑树就把HashMap和TreeMap联系到了一起,因为TreeMap的底层实现就是红黑树。

-------------------

Q3:既然你说到了红黑树，那么我想问下为什么采用的是红黑树,而不是二叉搜索树呢?

A3:通常我们听到**二叉搜索树**的时候以为他是平衡树,其实不是。它只是左子树的值小于根节点，右子树的值大于根节点,如果构建根节点以后插入的数据是有序的，那么构造出来的二叉搜索树就不是平衡树，而是一个链表,那么它的时间复杂度就是O(n)。然而红黑树呢？就是通过每个节点标色的方式，每次更新数据后再平衡，以此来保证其查找效率。

----------------------------
Q4:那既然你说到这里了，再展开说一下它是怎么做到的每次插入都平衡?

A4:红黑树因为每个节点都有红色或者黑色这两种颜色，当然它也有一些特性，比如  
1. 根节点是黑色的。
2. 红色节点的子节点必须是黑色并且父节点也是黑色的。
3. 任何一条路径的黑色节点个数相同。

它通过这些特性再重新插入的时候做着色处理，配合左旋，右旋来达到最终的平衡。所以可以理解黑色红色其实是为了更好的辅助平衡。当有了这个着色以后配合红黑树的性质，就可以定义出来一个平衡的公式如下.首先插入的元素必须是红色,因为黑色破坏他的性质的几率更大。

- 假设X是新插入的节点，P是父节点,Y是叔父节点,G是祖父节点,P为G的左孩子。
1. 当Y为红色 ->P、Y变黑,G变红,X变G
2. 当Y为黑色,X是右孩子->左旋P,X变G
3. 当Y为黑色,X为左孩子->G变红,P变黑,右旋G
4. 当P为G的有孩子的时候,直接做镜像操作即可
    
	
- [参考资料](https://www.bilibili.com/video/av23890827)

-----------------------------

Q5:掌握的还不错,那来说说HashMap是不是线程安全的呢?  
A5:这个问题我不太清楚,要不然我回去研究一下,明天找你考考我?
