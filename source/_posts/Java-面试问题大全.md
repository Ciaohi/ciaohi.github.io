---
title: Java 面试问题大全之Java基础篇
date: 2019-10-19 22:37:59
tags: [Java,面试]
---

## 说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java 程序中如何检测？如何解决？

- 内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory；比如申请了一个 integer,但给它存了long 才能存下的数，那就是内存溢出。  
- 内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
- memory leak 会最终会导致 out of memory！


--------------

## 什么是 Java 的序列化，如何实现 Java 的序列化？列举在哪些程序中见过 Java 序列化？

- Java 中的序列化机制能够将一个实例对象（只序列化对象的属性值，而不会去序列化什么所谓的方法。）的状态信息写入到一个字节流中使其可以通过 socket 进行传输、或者持久化到存  
储  数据库或文件系统中；然后在需要的时候通过字节流中的信息来重构一个相同的对象。一般而言，要使得一个类可以序列化，只需简单实现 java.io.Serializable 接口即可.

- 对象的序列化主要有两种用途：
1. 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中。
2. 在网络上传送对象的字节序列。

- 在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是 Web 服务器中的 Session 对象，当有 10 万用户并发访问，就有可能出现   
10 万个 Session 对象，内存可能吃不消，于是 Web 容器就会把一些 seesion 先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。

- 当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个 Java 对象转换为字节序列，才能在网络上传送
；接收方则需要把字节序列再恢复为 Java 对象。

## Java 创建对象的几种方式
1. 用 new 语句创建对象，这是最常见的创建对象的方法。
2. 运用反射手段,调用 java.lang.Class 或者 java.lang.reflect.Constructor类的 newInstance()实例方法。
3. 调用对象的 clone()方法。
4. 运用反序列化手段，调用 java.io.ObjectInputStream 对象的readObject()方法。
- (1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。

## 匿名内部类可不可以继承或实现接口。为什么？

- 匿名内部类是没有名字的内部类,不能继承其它类,但一个内部类可以作为一个接口,由另一个内部类实现.
1. 由于匿名内部类没有名字，所以它没有构造函数。因为没有构造函数，所以它必须完全借用父类的构造函数来实例化，换言之：匿名内部类完全把创建对象的任务交给了父类去完成。
2. 在匿名内部类里创建新的方法没有太大意义，但它可以通过覆盖父类的方法达到神奇效果，如上例所示。这是多态性的体现。
3. 因为匿名内部类没有名字，所以无法进行向下的强制类型转换，持有对一个匿名内部类对象引用的变量类型一定是它的直接或间接父类类型。

## 在Java中，为什么基本类型不能做为 HashMap 的键值，而只能是引用类型，把引用类型做为 HashMap 的健值，需要注意哪些地方?

1. 在Java 中是使用泛型来约束 HashMap 中的 key 和 value 的类型的，即 HashMap<K, V>；而泛型在 Java 的规定中必须是对象 Object 类型的，也就是说 HashMap<K, V>可以理解为   
 HashMap<Object, Object>，很显然基本数据类型不是 Object 类型的，因此不能作为键值，只能是引用类型。虽然我们在 HashMap 中可以这样添加数据：“map.put(1, “Java”)；”，  
但实际上是将其中的 key 值 1 进行了自动装箱操作，变为了 Integer 类型。
2. 引用数据类型分为两类：系统提供的引用数据类型（如包装类、String等）以及自定义引用数据类型。系统提供的引用数据类型中已经重写了HashCode()和 equals()两个方法，所以能  
够保证 Map 中 key 值的唯一性；但是自定义的引用数据类型需要自己重写 HashCode()和 equals()这两个方法，以保证 Map 中 key 值的唯一性。

## 接口和抽象类的区别

### 相同点
- 抽象类和接口均包含抽象方法，类必须实现所有的抽象方法，否则是抽象类
- 抽象类和接口都不能实例化，他们位于继承树的顶端，用来被其他类继承和实现

### 两者的区别主要体现在两方面：语法方面和设计理念方面

1. 语法方面的区别是比较低层次的，非本质的，主要表现在：

- 接口中只能定义全局静态常量，不能定义变量。抽象类中可以定义常量和变量。
- 接口中所有的方法都是全局抽象方法。抽象类中可以有 0 个、1 个或多个，甚至全部都是抽象方法。
- 抽象类中可以有构造方法，但不能用来实例化，而在子类实例化是执行，完成属于抽象类的初始化操作。接口中不能定义构造方法。
- 一个类只能有一个直接父类（可以是抽象类），但可以充实实现多个接口
- 一个类使用 extends 来继承抽象类，使用 implements 来实现接口

2. 二者的主要区别还是在设计理念上，其决定了某些情况下到底使用抽象类还是接口。

- 抽象类体现了一种继承关系，目的是复用代码，抽象类中定义了各个子类的相同代码，可以认为父类是一个实现了部分功能的“中间产品”，而子类是“最终产品”。父类和子类之间必须存在“is-a”  
的关系，即父类和子类在概念本质上应该是相同的。

- 接口并不要求实现类和接口在概念本质上一致的，仅仅是实现了接口定义的约定或者能力而已。接口定义了“做什么”，而实现类负责完成“怎么做”，体现了功能（规范）和实现分离的原则。接口  
和实现之间可以认为是一种“has-a 的关系”。


## 同步代码块和同步方法有什么区别

### 相同点

- 同步方法就是在方法前加关键字synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待。而同步代码块则是在方法内部使用大括号使得一个代码块得到同步。同步代码块会有一  
个同步的“目标”，使得同步块更加灵活一些（同步代码块可以通过“目标”决定需要锁定的对象）。一般情况下，如果此“目标”为 this，同步方法和代码块没有太大的区别。

### 区别

- 同步方法直接在方法上加 synchronized 实现加锁，同步代码块则在方法内部加锁。很明显，同步方法锁的范围比较大，而同步代码块范围要小点。一般同步的范围越大，性能就越差。所以一般需要  
加锁进行同步的时候，范围越小越好，这样性能更好。


## 静态内部类和内部类有什么区别？

- 静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。非静态内部类能够访问  
外部类的静态和非静态成员。静态内部类不能访问外部类的非静态成员，只能访问外部类的静态成员。
- 实例化方式不同：1) 静态内部类：不依赖于外部类的实例，直接实例化内部类对象。2) 非静态内部类：通过外部类的对象实例生成内部类对象

## 反射的概念与作用


### 反射的概念：
- 反射，一种计算机处理方式。是程序可以访问、检测和修改它本身状态或行为的一种能力。
- Java 反射可以于运行时加载,探知和使用编译期间完全未知的类。
- 程序在运行状态中, 可以动态加载一个只有名称的类, 对于任意一个已经加载的类,都能够知道这个类的所有属性和方法; 对于任意一个对象,都能调用他的任意一个方法和属性;
- 加载完类之后, 在堆内存中会产生一个 Class 类型的对象(一个类只有一个 Class 对象), 这个对象包含了完整的类的结构信息,而且这个 Class 对象就像一面镜子,透过这个镜子看到类的结构,所以被  
称之为:反射.
- java 反射使得我们可以在程序运行时动态加载一个类，动态获取类的基本信息和定义的方法,构造函数,域等。
- 除了检阅类信息外，还可以动态创建类的实例，执行类实例的方法，获取类实例的域值。反射使 java 这种静态语言有了动态的特性。
### 反射的作用：

通过反射可以使程序代码访问装载到 JVM 中的类的内部信息
1. 获取已装载类的属性信息
2. 获取已装载类的方法
3. 获取已装载类的构造方法信息

### 反射的优点：
增加程序的灵活性。如 struts 中。请求的派发控制。当请求来到时。struts 通过查询配置文件。找到该请求对应的 action。已经方法。然后通过反射实例化 action。并调用响应 method。如果不适用  
反射，那么你就只能写死到代码里了。所以说，一个灵活，一个不灵活。很少情况下是非用反射不可的。大多数情况下反射是为了提高程序的灵活性。因此一般框架中使用较多。因为框架要适用更多的情况。  
对灵活性要求较高。


## int 与 Integer 有什么区别？
- int 是 java 提供的 8 种原始数据类型之一。Java 为每个原始类型提供了封装类，Integer是java 为int 提供的封装类。int 的默认值为0，而Integer的默认值为 null，即 Integer 可以区分出未赋值和  
值为 0 的区别，int 则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为 0的区别，则只能使用 Integer。在 JSP 开发中，Integer 的默认为 null，所以用 el 表达式在文本框中  
显示时，值为空白字符串，而 int 默认的默认值为0，所以用 el 表达式在文本框中显示时，结果为 0，所以，int 不适合作为web层的表单数据的类型。

-  在Hibernate 中，如果将 OID 定义为 Integer 类型，那么 Hibernate就可以根据其值是否为 null 而判断一个对象是否是临时的，如果将 OID 定义为了 int 类型，还需要在 hbm 映射文件中设置其 unsaved-value   
属性为0。另外，Integer 提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer 中还定义了表示整数的最大值和最小值的常量。

## 可序列化对象为什么要定义 serialversionUID 值?
SerialVersionUid，简言之，其目的是序列化对象版本控制，有关各版本反序列化时是否兼容。如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出 InvalidClassException 异常。如果  
修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即   
SerialVersionUid。


## Class 类的 getDeclaredFields()方法与 getFields()的区别？
- getDeclaredFields(): 可以获取所有本类自己声明的方法, 不能获取继承的方法
- getFields(): 只能获取所有 public 声明的方法, 包括继承的方法


## 描述&和&&的区别

- &和&&的联系(共同点)： &和&&都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。操作数 1&操作数 2，操作数 1&&操作数 2，表达式 1&表达式 2，表达式 1&&表达式 2，  

1. 情况 1：当上述的操作数是 boolean 类型变量时，&和&&都可以用作逻辑与运算符。
2. 情况 2：当上述的表达式结果是 boolean 类型变量时，&和&&都可以用作逻辑与运算符。
3. 表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为 true 时，整个运算结果才为 true，否则，只要有一方为 false，结果都为 false。 

- &和&&的区别(不同点)：

1. &逻辑运算符称为逻辑与运算符，&&逻辑运算符称为短路与运算符，也可叫逻辑与运算符。
2. 对于&：无论任何情况，&两边的操作数或表达式都会参与计算。
3. 对于&&：当&&左边的操作数为 false 或左边表达式结果为 false 时，&&右边的操作数或表达式将不参与计算，此时最终结果都为 false。


综上所述，如果逻辑与运算的第一个操作数是 false 或第一个表达式的结果为 false 时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是 false。推介平时多使用&&，因为它效率  
更高些。&还可以用作位运算符。当&两边操作数或两边表达式的结果不是boolean 类型时，&用于按位与运算符的操作。

## 使用 final 关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？

final 修饰基本类型变量，其值不能改变。但是 final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。  

例如：

```java
class Test {
	public static void main(String[] args) {
	final Dog dog = new Dog("欧欧");
	dog.name = "美美";//正确
	dog = new Dog("亚亚");//错误
	} 
}

```



## 请解释以下常用正则含义：\d,\D,\s,.,*,?,|,[0-9]{6},\d+
- \d: 匹配一个数字字符。等价于[0-9]
- \D: 匹配一个非数字字符。等价于[^0-9]
- \s: 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]
- . ：匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。 
- \*：匹配前面的子表达式零次或多次。要匹配\* 字符，请使用 \*。 
- +：匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。
- |:将两个匹配条件进行逻辑“或”（Or）运算
- [0-9]{6}:匹配连续 6 个 0-9 之间的数字
- \d+：匹配至少一个 0-9 之间的数字


## 什么是编译型语言，什么是解释型语言？java 可以归类到那种？

计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言翻译成机器语言，计算机才能运行高级语言所编写的程序。翻译的方式有两种，一个是编译，一个是解释。

- 用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统把高级语言翻译成机器语言，把源高级程序编译成为机器语言文件，比如 windows 下的 exe 文件。以后就可以直接运行而  
不需要编译了，因为翻译只做了一次，运行时不需要翻译，所以一般而言，编译型语言的程序执行效率高。

- 解释型语言在运行的时候才翻译，比如 VB 语言，在执行的时候，专门有一个解释器能够将 VB 语言翻译成机器语言，每个语句都是执行时才翻译。这样解释型语言每执行一次就要翻译一次，效率比较低。

- 编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像 C/C++、Pascal/Object Pascal（Delphi）  
等都是编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如JavaScript、VBScript、Perl、Python、Ruby、MATLAB 等等。

- JAVA 语言是一种编译型-解释型语言，同时具备编译特性和解释特性（其实，确切的说 java 就是解释型语言，其所谓的编译过程只是将.java 文件编程成平台无关的字节码.class 文件，并不是向 C 一样编 
译成可执行的机器语言，在此请读者注意 Java 中所谓的“编译”和传统的“编译”的区别）。作为编译型语言，JAVA 程序要被统一编译成字节码文件——文件后缀是class。此种文件在 java 中又称为类文件。  
java 类文件不能在计算机上直接执行，它需要被 java 虚拟机翻译成本地的机器码后才能执行，而 java 虚拟机的翻译过程则是解释性的。java 字节码文件首先被加载到计算机内存中，然后读出一条指令，  
翻译一条指令，执行一条指令，该过程被称为 java 语言的解释执行，是由 java 虚拟机完成的。


## try{}里面有一个 return 语句，那么紧跟在这个 try 后的finally, 里面的语句在异常出现后，都会执行么？为什么？
在异常处理时提供 finally 块来执行任何清除操作。如果有 finally 的话，则不管是否发生异常，finally 语句都会被执行，包括遇到 return 语句。finally 中语句不执行的唯一情况中执行了 System.exit(0)语句。

## 一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？
构造方法可以被重载，但是构造方法不能被重写，子类也不能继承到父类的构造方法


## Java 中byte 表示的数值范围是什么？

范围是-128 至 127


## 成员变量用 static 修饰和不用 static 修饰有什么区别

1. 两个变量的生命周期不同。成员变量随着对象的创建而存在，随着对象的被回收而释放。静态变量随着类的加载而存在，随着类的消失而消失。
2. 调用方式不同。成员变量只能被对象调用。静态变量可以被对象调用，还可以被类名调用。对象调用：p.country类名调用 ：Person.country
3. 别名不同。成员变量也称为实例变量。静态变量称为类变量。
4. 数据存储位置不同。成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据.静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据.


## 如果变量用 final 修饰，则怎样？如果方法 final 修饰，则怎样?

- 用 final 修饰的类不能被扩展，也就是说不可能有子类；
- 用 final 修饰的方法不能被替换或隐藏：
1. 使用 final 修饰的实例方法在其所属类的子类中不能被替换（overridden）
2. 使用 final 修饰的静态方法在其所属类的子类中不能被重定义（redefined）而隐藏 （hidden）；
3. 用 final 修饰的变量最多只能赋值一次，在赋值方式上不同类型的变量或稍有不同：
- 静态变量必须明确赋值一次（不能只使用类型缺省值）；作为类成员的静态变量，赋值可以在其声明中通过初始化表达式完成，也可以在静态初始化块中进行；作为接口成员的静态变量，赋值只能在其声  
明中通过初始化表达式完成；
- 实例变量同样必须明确赋值一次（不能只使用类型缺省值）；赋值可以在其声明中通过初始化表达式完成，也可以在实例初始化块或构造器中进行；
- 方法参数变量在方法被调用时创建，同时被初始化为对应实参值，终止于方法体 （body）结束，在此期间其值不能改变；
- 构造器参数变量在构造器被调用（通过实例创建表达式或显示的构造器调用）时创建，同时被初始化，为对应实参值，终止于构造器体结束，在此期间其值不能改变；
- 异常处理器参数变量在有异常被 try 语句的 catch 子句捕捉到时创建，同时被初始化为实际的异常对象，终止于 catch 语句块结束，在此期间其值不能改变；
- 局部变量在其值被访问之前必须被明确赋值；



## int 和 Integer 有什么区别?

- Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入不是对象的基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型  
（wrapper class），int 的包装类就是 Integer，从 JDK 1.5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。Java 为每个原始类型提供了包装类型：原始类型: boolean，char，byte，short，  
int，long，float，double.包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double.

- 如果不明就里很容易认为两个输出要么都是 true 要么都是 false。首先需要注意的是 f1、f2、f3、f4 四个变量都是 Integer 对象，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们  
给一个 Integer 对象赋一个 int 值的时候，会调用 Integer 类的静态方法 valueOf，如果看看valueOf 的源代码就知道发生了什么。简单的说，如果字面量的值在-128 到 127 之间，那么不会 new 新的 Integer  
对象，而是直接引用常量池中的 Integer 对象，所以上面的面试题中 f1==f2的结果是 true，而 f3==f4 的结果是 false。越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。

## &和&&的区别？

&运算符有两种用法：(1)按位与；(2)逻辑与。&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。&&之所以称为短路  
运算是因为，如果&&左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写  
为：username != null &&!username.equals(“”)，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 NullPointerException 异常。注意：  
逻辑或运算符（|）和短路或运算符（||）的差别也是如此。补充：如果你熟悉 JavaScript，那你可能更能感受到短路运算的强大，想成为 JavaScript 的高手就先从玩转短路运算开始吧。

## Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?

Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。


## 简述 Java 的垃圾回收机制
传统的 C/C++语言，需要程序员负责回收已经分配内存。显式回收垃圾回收的缺点：
1. 程序忘记及时回收，从而导致内存泄露，降低系统性能。
2. 序错误回收程序核心类库的内存，导致系统崩溃。
- Java语言不需要程序员直接控制内存回收，是由 JRE 在后台自动回收不再使用的内存，称为垃圾回收机制，简称 GC；
1. 可以提高编程效率。
2. 保护程序的完整性。
3. 其开销影响性能。Java 虚拟机必须跟踪程序中有用的对象，确定哪些是无用的。
垃圾回收机制的特点
1. 垃圾回收机制回收 JVM 堆内存里的对象空间,不负责回收栈内存数据。
2. 对其他物理连接，比如数据库连接、输入流输出流、Socket 连接无能为力。
3. 垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。
4. 可以将对象的引用变量设置为 null，暗示垃圾回收机制可以回收该对象。
现在的 JVM 有多种垃圾回收实现算法，表现各异。垃圾回收机制回收任何对象之前，总会先调用它的 finalize 方法（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）。程序员  
可以通过 System.gc()或者 Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有一些效果，但是系统是否进行垃圾回收依然不确定。永远不要主动调用某个对象的 finalize 方法，应该交给垃圾回  
收机制调用。

## 为什么为基本类型引入包装类
1. 基本数据类型有方便之处，简单、高效。
2. 但是 Java 中的基本数据类型却是不面向对象的（没有属性、方法），这在实际使用时存在很多的不便（比如集合的元素只能是 Object）。为了解决这个不足，在设计类时为每个基本数据类型设计了一个  
对应的类进行包装，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。
3. 包装类和基本数据类型之间的转换
- 包装类------ wrapperInstance.xxxValue() ------>基本数据类型
- 包装类-------new WrapperClass(primitive) new WrapperClass(string)------基本数据类型
4. 自动装箱和自动拆箱
JDK1.5 提供了自动装箱（autoboxing）和自动拆箱（autounboxing）功能, 从而实现了包装类和基本数据类型之间的自动转换
5) 包装类还可以实现基本类型变量和字符串之间的转换
- 基本类型变量------------String.valueof()------------>字符串
- 基本类型变量------------WrapperClass.parseXxx(string)------------>字符串

## java.sql.Date 和 java.util.Date 的联系和区别

1. java.sql.Date 是 java.util.Date 的子类，是一个包装了毫秒值的瘦包装器，允许 JDBC 将毫秒值标识为 SQL DATE 值。毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与   
SQL DATE 的定义一致，由 java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫秒设置为与该实例相关的特定时区中的零来“规范化”。 说白了，java.sql.Date 就是与数据库 Date 相对应的一  
个类型，而 java.util.Date 是纯java的 Date。
2. JAVA 里提供的日期和时间类，java.sql.Date 和 java.sql.Time,只会从数据库里读取某部分值，这有时会导致丢失数据。例如一个包含 2002/05/22 5:00:57 PM 的字段，读取日期时得到的是 2002/05/22,  
而读取时间时得到的是 5:00:57 PM. 你需要了解数据库里存储时间的精度。有些数据库，比如MySQL,精度为毫秒，然而另一些数据库，包括 Oracle,存储 SQL DATE 类型数据时，毫秒部分的数据是不保存的。  
以下操作中容易出现不易被发现的BUG：获得一个 JAVA 里的日期对象。 从数据库里读取日期 试图比较两个日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象用Equals 方法可能返回 false。  
.sql.Timestamp 类比 java.util.Date 类精确度要高。这个类包了一个 getTime()方法，但是它不会返回额外精度部分的数据，因此必须使用...总之，java.util.Date 就是 Java 的日期对象，而 java.sql.Date   
是针对 SQL句使用的，只包含日期而没有时间部分。

## 面向对象的特征有哪些方面？请用生活中的例子来描述。
- 面向对象的三大特征：封装、继承、多态。举例：（比如设计一个游戏）我现在创建了一个对象，名叫战士。  战士的属性是—性别，年龄，职业，等级，战斗力，血量。  它的方法—战斗，逃跑，吃饭，  
睡觉，死。  后来，我又建了一个对象，叫人。属性:性别，年龄，职业，等级，血量.方法:逃跑，吃饭，睡觉，死。我让人，成为战士的父类，战士可以直接继承人的属性和方法。战士修改成—属性:战斗力。
方法:战斗。看上去战士的资料变少了，实际上没有，我们仍然可以调用方法—战士.死。而且我们还可以重载战士.死的方法，简称重载死法。我还建了一个对象—法师，父类也是人。属性:法力值方法:施法，泡  
妞。你看，用了继承，创建对象变得更方便了。再后来，我又建立了一个对象，叫怪物。属性:等级，战力，血量。方法:战斗，死。建了个对象，叫白兔怪，父类怪物，可继承怪物所有的属性和方法。属性:  
毛色。方法:卖萌，吃胡萝卜。

- 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现  
细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣  
机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。

- 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的  
方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时，B 系统有多种提供服务的方式，但一切对 A 系统来说都是透明的（就像电动剃须刀是 A 系统，它的  
供电系统是 B 系统，B 系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A 系统只会通过 B 类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。  
方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：  
1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；
2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。



## Java 中 Math.random（）/Math.random（）值为？
如果除数与被除数均不为 0.0 的话，则取值范围为[0, +∞]。+∞在 Java 中显示的结果为 Infinity。如果除数与被除数均为 0.0 的话，则运行结果为 NaN（Not a Number 的简写），计算错误。


## Java 中，如果 Manager 是 Employee 的子类，那么Pair<Manager>是 Pair<Employee>的子类吗？

不是，两者没有任何关联；Pair 是单独的类，只不过用不同类型的参数（泛型）进行了相应的实例化而已；所以，Pair<Manager>和 Pair<Employee>不是子类的关系。

## 解释继承、重载、覆盖。
- 继承（英语：inheritance）是面向对象软件技术当中的一个概念。如果一个类别 A“继承自”另一个类别 B，就把这个 A 称为“B 的子类别”，而把 B称为“A 的父类别”也可以称“B 是 A 的超类”。继承可以  
使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不  
同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类别的行为在编译期就已经决定，无法在执行期扩充。那么如何使用继承呢？  
用 extends 关键字来继承父类。如上面 A 类与 B 类，当写继承语句时， class A 类 extends B 类{ } 其中 A类是子类，B 类是父类。



|                |英文    |  位置不同  |  作用不同 |
| :-----: | :----: | :-------| :----------|
| 重载 |  overload | 同一个类中  |  在一个类里面为一种行为提供多种实现方式并提高可读性|
|  重写| override  |  子类和父类间 | 父类方法无法满足子类的要求，子类通过方法重写满足要求|

|                |修饰符    |  返回值  |  方法名 | 参数 | 抛出异常|
| :-----: | :----: | :-------| :----------: | :-------: | :-------: |
| 重载 |  无关 | 无关  |  相同 |不同 |无关 |
|  重写| 大于等于  |  小于等于 |相同|相同 |小于等于 |


- 重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载（overload）发生在同一个类中，相同的方法，如果有不同的参数列表（参数类型不同、参  
数个数不同或者二者都不同）则视为重载；重写（override）发生在子类与父类之间也就是继承机制当中，当父类的方法不能满足子类的要求，此时子类重写父类的方法；要求：方法名、形参列表相同；返回  
值类型和异常类型，子类小于等于父类；访问权限，子类大于等于父类，切记父类的私有方法以及被 final 修饰的方法不能被子类重写；重载对返回类型没有特殊的要求。





## Java 中 byte 表示的数值范围是什么？

范围是-128 至 127


## Java 中 int.long 占用的字节数分别是

1. “字节”是 byte，“位”是 bit ； 
2. 1 byte = 8 bit ；char 在 Java 中是 2 个字节。java 采用 unicode，2 个字节（16 位）来表示一个字符。short 2 个字节,int 4 个字节,long 8 个字节.

## 成员变量用 static 修饰和不用 static 修饰有什么区别

1. 两个变量的生命周期不同。成员变量随着对象的创建而存在，随着对象的被回收而释放。静态变量随着类的加载而存在，随着类的消失而消失。
2. 调用方式不同。成员变量只能被对象调用。静态变量可以被对象调用，还可以被类名调用。对象调用：p.country类名调用 ：Person.country
3. 别名不同。成员变量也称为实例变量。静态变量称为类变量。
4. 数据存储位置不同。成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据.静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据.

## 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？

- 不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hash code）应当相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1)如果两个对象相同（equals 方法返回 true）  
，那么它们的hashCode 值一定要相同；(2)如果两个对象的 hashCode 相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在   
Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。

- 补充：关于 equals 和 hashCode 方法，很多 Java 程序都知道，但很多人也就是仅仅知道而已，在 Joshua Bloch 的大作《Effective Java》（很多软件公司，《Effective Java》、《Java 编程思想》  
以及《重构：改善既有代码质量》是 Java 程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍 equals 方法的：首先 equals 方法必须满足自反性（x.equals(x)必须返回 true）  
、对称性（x.equals(y)返回 true 时，y.equals(x)也必须返回 true）、传递性（x.equals(y)和 y.equals(z)都返回 true 时，x.equals(z)也必须返回 true）和一致性（当 x 和 y 引用的对象信息没有  
被修改时，多次调用 x.equals(y)应该得到同样的返回值），而且对于任何非 null值的引用 x，x.equals(null)必须返回 false。实现高质量的 equals 方法的诀窍包括：1. 使用==操作符检查“参数是否为  
这个对象的引用”；2. 使用instanceof 操作符检查“参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完 equals 方法后，问自己它是否满足对称性、  
传递性、一致性；5. 重写 equals 时总是要重写hashCode；6. 不要将 equals 方法参数中的 Object 对象替换为其他的类型，在重写时不要忘掉@Override 注解。



## 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?

- 是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。    
- C++和 C#中可以通过传引用或传输出参数来改变传入的参数的值。补充：Java 中没有传引用实在是非常的不方便，这一点在 Java 8 中仍然没有得到改进，正是如此在Java 编写的代码中  才会出现大 
量的Wrapper类（将需要通过方法调用修改的引用置于一个 Wrapper 类中，再将 Wrapper 对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从 C 和 C++转型为 Java 程序员的开发者无法容忍。



## 静态嵌套类(Static Nested Class)和内部类（Inner Class）

- 内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，  
过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似 c 语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把“全局变量”放在内部类中就是毫无意  
义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中。

- 在方法体外面定义的内部类的访问类型可以是 public,protect,默认的，private 等 4 种类型，这就好像类中定义的成员变量有 4 种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这 
种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，代码如下：Outer outer = new Outer();  
uter.Inner1 inner1 = outer.new Innner1();在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用 final 或 abstract 修饰符。这种内部类  
对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部  
变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加 final 修饰符。对于这些细节，只要在 eclipse 写代码试试，根据开发工具提示的各类错误
信息就可以马上了解到。

- 在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称：最后，在方法外部定义的内部类前面可以加上 static 关键字，  
从而成为 Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class 与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它  
可以定义成 public、protected、默认的、private 等多种类型，而普通类只能定义成 public 和默认的这两种类型。在外面引用 Static Nested Class 类的名称为“外部类名.内部类名”。在外面不需要创建外部类的  
实例对象，就可以直接创建 Static Nested Class。

- 例如，假设 Inner 是定义在 Outer 类中的 Static Nested Class，那么可以使用如下语句创建 Inner 类：Outer.Inner inner = newOuter.Inner();由于 static Nested Class 不依赖于外部类的实例对象，  
所以，static Nested Class 能访问外部类的非 static 成员变量(不能直接访问，需要创建外部类实例才能访问非静态变量)。当在外部类中访问 Static Nested Class 时，可以直接使用 Static Nested Class   
的名字，而不需要加上外部类的名字了，在Static Nested Class 中也可以直接引用外部类的 static 的成员变量，不需要加上外部类的名字。在静态方法中定义的内部类也是 Static Nested Class，这时候不能在  
类前面加 static 关键字，静态方法中的 Static Nested Class 与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的 static 的成员变量，还可以访问静态方法中的局部变量，但是，该局部  
变量前必须加 final 修饰符。
- 备注：首先根据你的印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的  
语法区别，静态内部类，以及匿名内部类。Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，
其语法看起来挺诡异的，如下所示。



## 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized 修饰?
- 都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized 和方法的  
实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。


## 静态变量和实例变量的区别？

- 静态变量是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先  
创建对象然后通过对象才能访问到它，静态变量可以实现让多个对象共享内存。两者的相同点：都有默认值而且在类的任何地方都可以调用。在 Java 开发中，上下文类和工具类中通常会有大量的静态成员。


##  是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？

- 不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。

## 如何实现对象克隆？

1. 实现 Cloneable 接口并重写 Object 类中的 clone()方法；
2. 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆

- 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于  
使用 Object 类的clone 方法克隆对象。

## 接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?

- 接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继承具体类。抽象类中可以有静态的 main 方法。
- 备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是 java 语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案  
就是肯定的了。只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract 方法。

## 一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？

- 可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。


## Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？

- 可以继承其他类或实现其他接口，在 Swing 编程中常用此方式来实现事件监听和回调。 但是有一点需要注意，它只能继承一个类或一个接口。

## 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？

- 一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。如果要访问外部类的局部变量，此时局部变量必须使用 final 修饰，否则无法访问。


## Java 中的 final 关键字有哪些用法？

1. 修饰类：表示该类不能被继承；
2. 修饰方法：表示方法不能被重写但是允许重载；
3. 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）；
4. 修饰对象：对象的引用地址不能变，但是对象的初始化值可以变。


## 创建对象时构造器的调用顺序是

- 先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。考点：静态代码块优先级 > 构造方法的优先级
- 如果再加一个普通代码块，优先顺序如下：静态代码块>普通代码块>构造方法


## 说说数据类型之间的转换:

1. 如何将字符串转换为基本数据类型？
-  调用基本数据类型对应的包装类中的方法 parseXXX(String)或valueOf(String)即可返回相应基本类型；
2. 如何将基本数据类型转换为字符串？

- 一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用 String 类中的 valueOf(…)方法返回相应字符串


## 如何实现字符串的反转及替换？

- ：方法很多，可以自己写实现也可以使用 String 或 StringBuffer / StringBuilder 中的方法。有一道很常见的面试题是用递归实现字符串反转。

## Java 中的日期和时间：


1. 如何取得年月日、小时分钟秒？
2. 如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？
3. 如何取得某月的最后一天？
4. 如何格式化日期？
- 操作方法如下所示：
1. 创建 java.util.Calendar 实例，调用其 get()方法传入不同的参数即可获得参数所对应的值
2. 以下方法均可获得该毫秒数:
```bash
   Calendar.getInstance().getTimeInMillis(); 
   System.currentTimeMillis();
```
3. 示例代码如下:

```bash
	Calendar time = Calendar.getInstance();
    System.out.println(time.getActualMaximum(Calendar.DAY_OF_MONTH));
```

4. 利用 java.text.DataFormat 的子类（如 SimpleDateFormat 类）中的format(Date)方法可将日期格式化。

## Java 反射技术主要实现类有哪些，作用分别是什么？

- JDK 中，主要由以下类来实现 Java 反射机制，这些类都位于java.lang.reflect 包中
1. Class 类：代表一个类
2. Field 类：代表类的成员变量(属性) 
3. Method 类：代表类的成员方法
4. Constructor 类：代表类的构造方法
5. Array 类：提供了动态创建数组，以及访问数组的元素的静态方法



## Class 类的作用？生成 Class 对象的方法有哪些？

- Class 类是 Java 反射机制的起源和入口，用于获取与类相关的各种信息，提供了获取类信息的相关方法。Class 类继承自 Object 类Class 类是所有类的共同的图纸。每个类有自己的对象，好比图纸和实  
物的关系；每个类也可看做是一个对象，有共同的图纸 Class，存放类的 结构信息，能够通过相应方法取出相应信息：类的名字、属性、方法、构造方法、父类和接口

|方法|事例|
| :-----: | :--------: |
| 对象名.getClass()| String str="bdqn";Class clazz = str.getClass();|
| 对象名.getSuperClass()|Student stu = new Student();Class c1 = stu.getClass();Class c2 = stu.getSuperClass();|
| 类名.class| Class c1 = String.class;Class c2 = Student.class;Class c2 = int.class|
| 包装类.TYPE| Class c1 = Integer.TYPE;Class c2 = Boolean.TYPE;|


## 反射的使用场合和作用、及其优缺点

1. 使用场合
- 在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息。
2. 主要作用
- 通过反射可以使程序代码访问装载到 JVM 中的类的内部信息，获取已装载类的属性信息，获取已装载类的方法，获取已装载类的构造方法信息
3. 反射的优点
- 反射提高了 Java 程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创建和控制任何类的对象，无需提前硬编码目标类；反射是其它一些常用语言，如 C、C++、Fortran 或者 Pascal 等都不具备的.

4. Java 反射技术应用领域很广，如软件测试等；许多流行的开源框架例如Struts、Hibernate、Spring 在实现过程中都采用了该技术
5. 反射的缺点
- 性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此 Java 反射机制主要应用在对灵活性和扩展性要求很高的系统框架上,普通程序不建议使用。
- 使用反射会模糊程序内部逻辑：程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂。


## 面向对象设计原则有哪些

面向对象设计原则是面向对象设计的基石，面向对象设计质量的依据和保障，设计模式是面向对象设计原则的经典应用

1. 单一职责原则 SRP
2. 开闭原则 OCP
3. 里氏替代原则 LSP
4. 依赖注入原则 DIP
5. 接口分离原则 ISP
6. 迪米特原则 LOD
7. 组合/聚合复用原则 CARP
8. 开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他设计原则都可以看作是开闭原则的实现手段或方法






